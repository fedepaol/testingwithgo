Cover your Go code with tests

Federico Paolinelli
List
@fedepaol
fedepaol@gmail.com
federico@list-group.com

* About me

- Lead developer at List
- Moving from C on daily basis to golang
- Open source lover

* Agenda

- Intro to testing
- Testing with go
- Advanced testing patterns with go

* The need for tests

* We do change our code.
Reasons we change:
- New features
- Fixing a bug
- Refactor (better readability / easier to maintain)
- Optimization

: That's what they pay us for

* We need to preserve the behaviour

.image behaviour.png 

: Every time we change a program that is behaving in a correct way, we put it's correctness in discussion.
: This is important. When we change a part of our code, the rest is supposed to preserve its behaviour


* The cost of a bug
Fixing a production bug costs 100x more than fixing a bug at design time, and over 15x more than fixing a bug at implementation time.

TODO insert picture here

.caption from [[https://www.researchgate.net/publication/255965523_Integrating_Software_Assurance_into_the_Software_Development_Life_Cycle_SDLC][TODO INSERT TITLE HERE]]

* 

Changes in a system can be made in two primary ways. I like to call them Edit and Pray and Cover and Modify. 

Unfortunately, Edit and Pray is pretty much the industry standard


.caption Micheal Feathers - Working effectively with legacy code

: Covering means covering with tests

* What about manual tests?

* What Unit tests are

".. We asked him (Kent Beck) for his definition and he replied with something like "in the morning of my training course I cover 24 different definitions of unit test."
.caption Martin Fowler [[https://martinfowler.com/bliki/UnitTest.html][ibliki: UnitTest]]

* Common characteristics of tests

- Low level, focus on a small part of the system
- Written by programmers
- Faster than normal tests

* What to treat like a unit?

- A class?
- A function?

: We will see that go takes a slightly different approach

* Other benefits of testing
- Quality
- Self documenting
- Result in a better design
- Reduce costs
- Automation

* Testing in Go

: or, what do you need to know in order to understand the next part

* User defined data structures

Go Structs

	type book struct {
		title string
		author string
	}

	var b book	// zero value
	var b1 book{title:"Golang"} // literal initializer

: no inheritance
: no generics
: enforce composition through embedding

* Methods

- Just a special kind of functions (they have a receiver)
- Explicitly associated to objects or pointers

	type Dog struct {
		Animal
	}

	func (d Dog) bark() {
		// bark
	}

	func (d *Dog) feed() {
		d.weight++
	}

: can assign methods to any type, even those you don't own

* Interfaces

- Abstract types defining a behaviour
- Satisfied implicitly 

	type Driveable interface {
		func Drive() int
	}

	func (c Car) Drive (km int) {/* */}
	func (b Bike) Drive (km int) {/* */}

	var c Car{wheels : 4}
	var d Driveable = c

_If_it_walks_like_a_duck_and_quacks_as_a_duck,_it's_a_duck_

: But the compiler tells you if you made a mistake
: You can create interfaces that are satisfied by structs you don't own.

* Interfaces (2)

- Can be composed

	type ReadWriter interface {
		Reader
		Writer
	}


- Can be checked

	c, ok := d.(Car) // true
	c, ok := d.(Bike)  // false

	switch d.(type) {
		case Car: //
	}

: you can retro assign an interface to any object
: Interfaces can be used as a placeholder to use different concrete types 

* Encapsulation

.image encapsulation.jpeg _ 400

* Encapsulation in Go:

- The visibility is related to the _package_
- Multiple files can belong to the same package
- The visibility is toggled by uppercasing / lowercasing 


Every file belongs to a package

	package mypackage

	var Exported int
	var notExported string


* The go test tool

* Test files

From the stdlib strings package:

	src/.../
		strings/
			builder.go 	
			builder_test.go
			compare.go
			compare_test.go
			example_test.go
			export_test.go
			reader.go
			reader_test.go
			replace.go
			replace_test.go
			search.go
			search_test.go
			strings.go
			strings_decl.go
			strings_test.go

: Files *_test are not part of the package. They are built by go test
: go test generates a temporary main and executes it

* Test functions

.code reverse/totest.go 
.code reverse/totest_test.go

: The go test tool looks for function that look like Test*
: Very raw functionalities compared to other languages / testing frameworks (jUnit)

* Go test execution

A failing test:

	go test
	--- FAIL: TestReverse (0.00s)
	    totest_test.go:8: Reverse("gdgolleh") = hellogdg
	FAIL
	exit status 1
	FAIL    _/home/fedepaol/devel/talks/testingwithgo       0.001s

A passing test:

	go test
	PASS
	ok      _/home/fedepaol/devel/talks/testingwithgo       0.001s

: We don't want output when a test passes. We do want output with info when a test fails

* Other go test features

* Coverage

	go test -cover
		PASS
		coverage: 100.0% of statements
		ok  	_/home/fedepaol/devel/talks/testingwithgo	0.001s

Also, `go tool cover`

	Usage of 'go tool cover':
	Given a coverage profile produced by 'go test':
		go test -coverprofile=c.out

	Open a web browser displaying annotated source code:
		go tool cover -html=c.out

* Benchmark

.code reverse/totestbench_test.go /START OMIT/,/END OMIT/

* Benchmark
	go test -bench=.
		goos: darwin
		goarch: amd64
		pkg: github.com/fedepaol/testingwithgo/reverse
								#Max number          #ns for each
								of iteration         iteration
		BenchmarkReverse4-4      5000000               226 ns/op
		BenchmarkReverse8-4      3000000               421 ns/op
		BenchmarkReverse16-4     1000000              1118 ns/op
		BenchmarkReverse32-4     1000000              1845 ns/op
		BenchmarkReverse64-4      500000              2808 ns/op
		PASS
		ok      github.com/fedepaol/testingwithgo/reverse       8.598s

- Each benchmark is run for a minimum of 1 second by default
- The value of b.N is increased in the sequence 1, 2, 5, 10, 20, 50, …
- The final BenchmarkReverse64 only ran 500000 times becaus each run has the average of 0,000002 sec (~2808ns/op) .
- if your number of runs are statically weak increase the bench time with `-benchtime=20s`

* Also:

- test results are cached: for same binary and same flags
disable 

	go clean -testcache

- Race detector
	go test -race mypackage
When the -race command-line flag is set, the compiler instruments all memory accesses 
with code that records when and how the memory was accessed, 
while the runtime library watches for unsynchronized accesses to shared variables

* Testable code

* What to test

Go naturally forces us to split our code in "libraries" and client code

- try to test only public functions
- test private functions worth being tested
- protip: use _package_xxx__test_
- test all the layers

* Package organization

- Use packages to isolate external dependencies
- Packages by functionality  
- Layered packages 
- Dependency Injection

.caption aws-sdk-go is a good example of package organization [[https://github.com/aws/aws-sdk-go/tree/master]]


: Ideally one package per dependency, it's easier to mock external dependencies
: Layering packages allow to test the whole 

* State
- Avoid global state
- Have global configuration
- Make parameters configurable

: No hardcoded hosts, ports, timeouts. Have them configurable (with a default)
: local variables / environment
: tests should be able to override them

*Functions*

- Have functions accept interfaces and return concrete types
- Prefer functions to methods

: The second one is counterintuitive if you come from oop. If the object does not get changed, is more clear what is teh input / output of the function
: Todo expand with an example?

* Accept interfaces and return concrete types

	// Don't
	func LineCounter(file os.File) int {
		...
	}

	// Do
	func LineCounter(r io.Reader) int {
		...
	}

: More generic. You can pass a stream from a socket, a file, whatever
: You can pass mocks: a fixed string

* Interfaces

- Interfaces are mocking points
- You can build interfaces against types you don't own
- Try to stick to stdlibs interfaces

: Should be used with care. 


* Mocking dependencies

* Interfaces:

Let's say we have a libray like this:

	type CakeClient struct {
	}

	// Ingredients returns the list of ingredients for the given cake
	func (l CakeClient) Ingredients(cake string) ([]string, err) {
		...
	}

And we want to test a function like this:

	func OrderIngredients(cake string, client CakeClient) {
		...
		ingredients, err := client.Ingredients(cake)
		...
	}

: The problem is, Ingredients hit a webserver every time. We don't want to do that in our test
: It's slow, we depned on the network

* Interfaces:

We can build an interface satisfied by CakeClient

	type Ingredienter interface {
		Ingredients(cake string) ([]string, err)
	}

And have our function accept an interface

	func OrderIngredients(cake string, i Ingredienter) {
		...
		ingredients, err := i.Ingredients(cake)
		...
	}

: What have we done here? We tailored our interface against the type

* Interfaces:

	type MockIngredienter struct {
		IngredientsMock func(cake string) ([]string, err)
	}

	func (m MockIngredienter) Ingredients(cake string) ([]string, err) {
		return m.IngredientsMock(cake)
	}

* Interfaces:

	func TestOrder(t *testing.T) {
		res := []string{"Flour", "Eggs", "Chocolate"}

		m := MockIngredienter{
			func(cake string) ([]string, err){
				return res, nil
			}
		}

		err := OrderIngredients("tiramisu", m)
		if err != nil {
			t.Errorf(`error with OrderIngredients("tiramisu", m)`)
		}
	}

: To sum up, we had a type, we implemented an interface satisfied by it, we used it and we mocked it.

* Package level functions

What if Ingredients was a plain function of the package?

	func Ingredients(cake string) ([]string, err) {

	}

Here is how to mock it

	var retrieveIngredients = testingwithgo.Ingredients

	func OrderIngredients(cake string) err {
		// testingwithgo.Ingredients(cake)
		retrieveIngredients(cake)
	}

* Package level functions (2)

	func TestOrderFunc(t *testing.T) {
		res := []string{"Flour", "Eggs", "Chocolate"}
		retrieveIngredients = func(cake string) ([]string, err) {
			return res, nil
		}
		defer retrieveIngredients = testingwithgo.Ingredients
		err := OrderIngredients("tiramisu")
	}



* Table tests
- Easy to add new test cases, just add new entry in the struct
: composite literals and anonymous structs, to allow you to write related tests in a compact form
- Give a name to the table -> easy to retrieve failed test 
: goland allows to run a single test 
- With functions, useful with mockery to instruct the mock beahviour (eg: return with error)
- testdata ignored by go
	
* Table tests
.code httptest/fibonaccitest.go


* Golden file tests:
Read the output from a file and compare. Provide a way using a test flag to update the content of the file.
Used in the standard lib to test fmt
* Flags:
- slow tests
* Integration tests
* Testing http calls
* Test fixtures - go test sets pwd as package dir. Use relative path to store configs, data, etc

* Test helpers: avoid, better copy / paste. Don't return errors in helpers, let them fail passing *T. More readable.
If test helper returns finalizers (ie close file), let them return as func() that gets deferred
-- NON SO SE QUESTO LO METTEREI

* Mockery
- https://github.com/vektra/mockery
- generate code from interfaces
    mockery -name MyDao -inpkg .
- similar to Java's Mockito 

    mock.On("MethodName", args...).Return(...)
- quantifiers `Once()`, `None()`, `Times(n)`
 
* Testify

* Do we always need mocks?

* Afero
- mocks a filesystem. 
- in memory or chrooted(~similar)
- useful for setup and tear down an isolated environment every time

* Networking
- Test the real connection, don't mock connections.
- Any protocol
- Setup a real server and test your handlers without mocks (eg http WebServer) 

	func HealthCheckHandler(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json")
		io.WriteString(w, `{"alive": true}`)
	}
    
* Networking(eg: http)
- *net/http/httptest*
.code httptest/httptest.go /START OMIT/,/END OMIT/

: Create a request to pass to our handler. We don't have any query parameters for now, so we'll
: pass 'nil' as the third parameter.
: We create a ResponseRecorder (which satisfies http.ResponseWriter) to record the response.
: Our handlers satisfy http.Handler, so we can call their ServeHTTP method
: directly and pass in our Request and ResponseRecorder.



* Subprocessing
Test the real subprocess / use a mock subprocess
Configure the executable name
Can be the process itself GO_WANT_HELPER_PROCESS
-- NON SO SE QUESTO LO METTEREI

Parlare di dockertest 
https://github.com/ory/dockertest
* Slow tests:
// +build integration
go test -tags=integration
