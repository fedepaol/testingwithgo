Cover your Go code with tests

Federico Paolinelli
List
@fedepaol
fedepaol@gmail.com
federico@list-group.com

* About me

- Lead developer at List
- Moving from C on daily basis to golang
- Open source lover

* Agenda

- Intro to testing
- Testing with go
- Advanced testing patterns with go

* The need for tests

* We do change our code.
Reasons we change:
- New features
- Fixing a bug
- Refactor (better readability / easier to maintain)
- Optimization

: That's what they pay us for

* We need to preserve the behaviour

.image behaviour.png 

: Every time we change a program that is behaving in a correct way, we put it's correctness in discussion.
: This is important. When we change a part of our code, the rest is supposed to preserve its behaviour


* The cost of a bug
Fixing a production bug costs 100x more than fixing a bug at design time, and over 15x more than fixing a bug at implementation time.

TODO insert picture here

.caption from [[https://www.researchgate.net/publication/255965523_Integrating_Software_Assurance_into_the_Software_Development_Life_Cycle_SDLC][TODO INSERT TITLE HERE]]

* 

Changes in a system can be made in two primary ways. I like to call them Edit and Pray and Cover and Modify. 

Unfortunately, Edit and Pray is pretty much the industry standard


.caption Micheal Feathers - Working effectively with legacy code

: Covering means covering with tests

* What about manual tests?

* What Unit tests are

".. We asked him (Kent Beck) for his definition and he replied with something like "in the morning of my training course I cover 24 different definitions of unit test."
.caption Martin Fowler [[https://martinfowler.com/bliki/UnitTest.html][ibliki: UnitTest]]

* Common characteristics of tests

- Low level, focus on a small part of the system
- Written by programmers
- Faster than normal tests

* What to treat like a unit?

- A class?
- A function?

: We will see that go takes a slightly different approach

* Other benefits of testing
- Quality
- Self documenting
- Result in a better design
- Reduce costs
- Automation

* Testing in Go

: or, what do you need to know in order to understand the next part

* User defined data structures

Go Structs

	type book struct {
		title string
		author string
	}

	var b book	// zero value
	var b1 book{title:"Golang"} // literal initializer

: no inheritance
: no generics
: enforce composition through embedding

* Methods

- Just a special kind of functions (they have a receiver)
- Explicitly associated to objects or pointers

	type Dog struct {
		Animal
	}

	func (d Dog) bark() {
		// bark
	}

	func (d *Dog) feed() {
		d.weight++
	}

: can assign methods to any type, even those you don't own

* Interfaces

- Abstract types defining a behaviour
- Satisfied implicitly 

	type Driveable interface {
		func Drive() int
	}

	func (c Car) Drive (km int) {/* */}
	func (b Bike) Drive (km int) {/* */}

	var c Car{wheels : 4}
	var d Driveable = c

_If_it_walks_like_a_duck_and_quacks_as_a_duck,_it's_a_duck_

: But the compiler tells you if you made a mistake
: You can create interfaces that are satisfied by structs you don't own.

* Interfaces (2)

- Can be composed

	type ReadWriter interface {
		Reader
		Writer
	}


- Can be checked

	c, ok := d.(Car) // true
	c, ok := d.(Bike)  // false

	switch d.(type) {
		case Car: //
	}

: you can retro assign an interface to any object
: Interfaces can be used as a placeholder to use different concrete types 

* Encapsulation

.image encapsulation.jpeg _ 400

* Encapsulation in Go:

- The visibility is related to the _package_
- Multiple files can belong to the same package
- The visibility is toggled by uppercasing / lowercasing 


Every file belongs to a package

	package mypackage

	var Exported int
	var notExported string


* The go test tool

* Test files

From the stdlib strings package:

	src/.../
		strings/
			builder.go 	
			builder_test.go
			compare.go
			compare_test.go
			example_test.go
			export_test.go
			reader.go
			reader_test.go
			replace.go
			replace_test.go
			search.go
			search_test.go
			strings.go
			strings_decl.go
			strings_test.go

: Files *_test are not part of the package. They are built by go test
: go test generates a temporary main and executes it

* Test functions

.code totest.go

.code totest_test.go

: The go test tool looks for function that look like Test*
: Very raw functionalities compared to other languages / testing frameworks (jUnit)

* Go test execution

A failing test:

	go test
	--- FAIL: TestReverse (0.00s)
	    totest_test.go:8: Reverse("gdgolleh") = hellogdg
	FAIL
	exit status 1
	FAIL    _/home/fedepaol/devel/talks/testingwithgo       0.001s

A passing test:

	go test
	PASS
	ok      _/home/fedepaol/devel/talks/testingwithgo       0.001s

: We don't want output when a test passes. We do want output with info when a test fails

* Other go test features

* Coverage

	go test -cover
		PASS
		coverage: 100.0% of statements
		ok  	_/home/fedepaol/devel/talks/testingwithgo	0.001s

Also, `go tool cover`

	Usage of 'go tool cover':
	Given a coverage profile produced by 'go test':
		go test -coverprofile=c.out

	Open a web browser displaying annotated source code:
		go tool cover -html=c.out

* Benchmark

.code totestbench_test.go

	go test -bench .
		goos: linux
		goarch: amd64
		BenchmarkReverse-4      30000000                40.7 ns/op
		PASS
		ok      _/home/fedepaol/devel/talks/testingwithgo       1.271s

* Also:

- test results are cached
- Race detector

* Testable code

* What to test

Go naturally forces us to split our code in "libraries" and client code

- try to test only public functions
- test private functions worth being tested
- protip: use _package_xxx__test_
- test all the layers

* Package organization

- Use packages to isolate external dependencies
- Packages by functionality
- Layered packages
- Dependency Injection

: Ideally one package per dependency, it's easier to mock external dependencies
: Layering packages allow to test the whole 

* State
- Avoid global state
- Have global configuration
- Make parameters configurable

: No hardcoded hosts, ports, timeouts. Have them configurable (with a default)
: local variables / environment
: tests should be able to override them

*Functions*

- Have functions accept interfaces and return concrete types
- Prefer functions to methods

: The second one is counterintuitive if you come from oop. If the object does not get changed, is more clear what is teh input / output of the function
: Todo expand with an example?

* Accept interfaces and return concrete types

	// Don't
	func LineCounter(file os.File) int {
		...
	}

	// Do
	func LineCounter(r io.Reader) int {
		...
	}

: More generic. You can pass a stream from a socket, a file, whatever
: You can pass mocks: a fixed string

* Interfaces

- Interfaces are mocking points
- You can build interfaces against types you don't own
- Try to stick to stdlibs interfaces

: Should be used with care. 


* Mocking dependencies

* Interfaces:

Let's say we have a libray like this:

	type CakeClient struct {
	}

	// Ingredients returns the list of ingredients for the given cake
	func (l CakeClient) Ingredients(cake string) ([]string, err) {
		...
	}

And we want to test a function like this:

	func OrderIngredients(cake string, client CakeClient) {
		...
		ingredients, err := client.Ingredients(cake)
		...
	}

: The problem is, Ingredients hit a webserver every time. We don't want to do that in our test
: It's slow, we depned on the network

* Interfaces:

We can build an interface satisfied by CakeClient

	type Ingredienter interface {
		Ingredients(cake string) ([]string, err)
	}

And have our function accept an interface

	func OrderIngredients(cake string, i Ingredienter) {
		...
		ingredients, err := i.Ingredients(cake)
		...
	}

: What have we done here? We tailored our interface against the type

* Interfaces:

	type MockIngredienter struct {
		IngredientsMock func(cake string) ([]string, err)
	}

	func (m MockIngredienter) Ingredients(cake string) ([]string, err) {
		return m.IngredientsMock(cake)
	}

* Interfaces:

	func TestOrder(t *testing.T) {
		res := []string{"Flour", "Eggs", "Chocolate"}

		m := MockIngredienter{
			func(cake string) ([]string, err){
				return res, nil
			}
		}

		err := OrderIngredients("tiramisu", m)
		if err != nil {
			t.Errorf(`error with OrderIngredients("tiramisu", m)`)
		}
	}

: To sum up, we had a type, we implemented an interface satisfied by it, we used it and we mocked it.

* Package level functions

What if Ingredients was a plain function of the package?

	func Ingredients(cake string) ([]string, err) {

	}

Here is how to mock it

	var retrieveIngredients = testingwithgo.Ingredients

	func OrderIngredients(cake string) err {
		// testingwithgo.Ingredients(cake)
		retrieveIngredients(cake)
	}

* Package level functions (2)

	func TestOrderFunc(t *testing.T) {
		res := []string{"Flour", "Eggs", "Chocolate"}
		retrieveIngredients = func(cake string) ([]string, err) {
			return res, nil
		}
		defer retrieveIngredients = testingwithgo.Ingredients
		err := OrderIngredients("tiramisu")
	}

* Do we always need mocks?

* Table tests
Easy to add new test cases
Give a name to the table -> easy to retrieve failed test
WIth functions!
testdata ignored by go

* Golden file tests:
Read the output from a file and compare. Provide a way using a test flag to update the content of the file.
Used in the standard lib to test fmt
* Flags:
- slow tests
* Integration tests
* Testing http calls
* Test fixtures - go test sets pwd as package dir. Use relative path to store configs, data, etc

* Test helpers: avoid, better copy / paste. Don't return errors in helpers, let them fail passing *T. More readable.
If test helper returns finalizers (ie close file), let them return as func() that gets deferred
-- NON SO SE QUESTO LO METTEREI

* Mockery
* Testify
* Afero
* Http

* Networking
Test the real connection, don't mock connections.
Any protocol

* Subprocessing
Test the real subprocess / use a mock subprocess
Configure the executable name
Can be the process itself GO_WANT_HELPER_PROCESS
-- NON SO SE QUESTO LO METTEREI

Parlare di dockertest 
https://github.com/ory/dockertest
* Slow tests:
// +build integration
go test -tags=integration
